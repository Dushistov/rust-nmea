var searchIndex = {};
searchIndex["nmea"] = {"doc":"","items":[[3,"Satellite","nmea","Satellite in view representation",null,null],[3,"Nmea","","NMEA parser",null,null],[4,"SentenceType","","NMEA sentence type",null,null],[13,"None","","",0,null],[13,"GGA","","",0,null],[13,"GSV","","",0,null],[4,"FixType","","Fix type",null,null],[13,"Invalid","","",1,null],[13,"Gps","","",1,null],[13,"DGps","","",1,null],[13,"Pps","","",1,null],[13,"Rtk","","",1,null],[13,"FloatRtk","","",1,null],[13,"Estimated","","",1,null],[13,"Manual","","",1,null],[13,"Simulation","","",1,null],[11,"new","regex::re_unicode","Compiles a regular expression. Once compiled, it can be used repeatedly\nto search, split or replace text in a string.",2,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"with_size_limit","","Compiles a regular expression with the given size limit.",2,{"inputs":[{"name":"usize"},{"name":"str"}],"output":{"name":"result"}}],[11,"is_match","","Returns true if and only if the regex matches the string given.",2,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"bool"}}],[11,"find","","Returns the start and end byte range of the leftmost-first match in\n`text`. If no match exists, then `None` is returned.",2,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"option"}}],[11,"find_iter","","Returns an iterator for each successive non-overlapping match in\n`text`, returning the start and end byte indices with respect to\n`text`.",2,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"findmatches"}}],[11,"captures","","Returns the capture groups corresponding to the leftmost-first\nmatch in `text`. Capture group `0` always corresponds to the entire\nmatch. If no match is found, then `None` is returned.",2,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"option"}}],[11,"captures_iter","","Returns an iterator over all the non-overlapping capture groups matched\nin `text`. This is operationally the same as `find_iter`, except it\nyields information about submatches.",2,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"findcaptures"}}],[11,"split","","Returns an iterator of substrings of `text` delimited by a match of the\nregular expression. Namely, each element of the iterator corresponds to\ntext that *isn&#39;t* matched by the regular expression.",2,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"regexsplits"}}],[11,"splitn","","Returns an iterator of at most `limit` substrings of `text` delimited\nby a match of the regular expression. (A `limit` of `0` will return no\nsubstrings.) Namely, each element of the iterator corresponds to text\nthat *isn&#39;t* matched by the regular expression. The remainder of the\nstring that is not split will be the last element in the iterator.",2,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"usize"}],"output":{"name":"regexsplitsn"}}],[11,"replace","","Replaces the leftmost-first match with the replacement provided.\nThe replacement can be a regular string (where `$N` and `$name` are\nexpanded to match capture groups) or a function that takes the matches&#39;\n`Captures` and returns the replaced string.",2,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"r"}],"output":{"name":"string"}}],[11,"replace_all","","Replaces all non-overlapping matches in `text` with the replacement\nprovided. This is the same as calling `replacen` with `limit` set to\n`0`.",2,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"r"}],"output":{"name":"string"}}],[11,"replacen","","Replaces at most `limit` non-overlapping matches in `text` with the\nreplacement provided. If `limit` is 0, then all non-overlapping matches\nare replaced.",2,{"inputs":[{"name":"regex"},{"name":"str"},{"name":"usize"},{"name":"r"}],"output":{"name":"string"}}],[11,"shortest_match","","Returns the end location of a match in the text given.",2,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"option"}}],[11,"as_str","","Returns the original string of this regex.",2,{"inputs":[{"name":"regex"}],"output":{"name":"str"}}],[11,"capture_names","","Returns an iterator over the capture names.",2,{"inputs":[{"name":"regex"}],"output":{"name":"capturenames"}}],[11,"captures_len","","Returns the number of captures.",2,{"inputs":[{"name":"regex"}],"output":{"name":"usize"}}],[11,"fmt","regex::backtrack","",3,{"inputs":[{"name":"bounded"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"cache"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"cache"}],"output":{"name":"cache"}}],[11,"new","","Create new empty cache for the backtracking engine.",4,{"inputs":[{"name":"program"}],"output":{"name":"cache"}}],[11,"fmt","","",5,{"inputs":[{"name":"job"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"job"}],"output":{"name":"job"}}],[11,"exec","","Execute the backtracking matching engine.",3,null],[11,"fmt","regex::compile","",6,{"inputs":[{"name":"patch"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new regular expression compiler.",7,{"inputs":[],"output":{"name":"compiler"}}],[11,"size_limit","","The size of the resulting program is limited by size_limit. If\nthe program approximately exceeds the given size (in bytes), then\ncompilation will stop and return an error.",7,{"inputs":[{"name":"compiler"},{"name":"usize"}],"output":{"name":"compiler"}}],[11,"bytes","","If bytes is true, then the program is compiled as a byte based\nautomaton, which incorporates UTF-8 decoding into the machine. If it&#39;s\nfalse, then the automaton is Unicode scalar value based, e.g., an\nengine utilizing such an automaton is resposible for UTF-8 decoding.",7,{"inputs":[{"name":"compiler"},{"name":"bool"}],"output":{"name":"compiler"}}],[11,"only_utf8","","When disabled, the program compiled may match arbitrary bytes.",7,{"inputs":[{"name":"compiler"},{"name":"bool"}],"output":{"name":"compiler"}}],[11,"dfa","","When set, the machine returned is suitable for use in the DFA matching\nengine.",7,{"inputs":[{"name":"compiler"},{"name":"bool"}],"output":{"name":"compiler"}}],[11,"reverse","","When set, the machine returned is suitable for matching text in\nreverse. In particular, all concatenations are flipped.",7,{"inputs":[{"name":"compiler"},{"name":"bool"}],"output":{"name":"compiler"}}],[11,"compile","","Compile a regular expression given its AST.",7,null],[11,"fmt","","",8,{"inputs":[{"name":"hole"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",9,{"inputs":[{"name":"maybeinst"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"maybeinst"}],"output":{"name":"maybeinst"}}],[11,"fmt","","",10,{"inputs":[{"name":"insthole"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"insthole"}],"output":{"name":"insthole"}}],[11,"eq","","",11,{"inputs":[{"name":"suffixcacheentry"},{"name":"suffixcacheentry"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"suffixcacheentry"},{"name":"suffixcacheentry"}],"output":{"name":"bool"}}],[11,"hash","","",11,null],[11,"default","","",11,{"inputs":[],"output":{"name":"suffixcacheentry"}}],[11,"fmt","","",11,{"inputs":[{"name":"suffixcacheentry"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"suffixcacheentry"}],"output":{"name":"suffixcacheentry"}}],[11,"eq","","",12,{"inputs":[{"name":"suffixcachekey"},{"name":"suffixcachekey"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"suffixcachekey"},{"name":"suffixcachekey"}],"output":{"name":"bool"}}],[11,"hash","","",12,null],[11,"default","","",12,{"inputs":[],"output":{"name":"suffixcachekey"}}],[11,"fmt","","",12,{"inputs":[{"name":"suffixcachekey"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"suffixcachekey"}],"output":{"name":"suffixcachekey"}}],[11,"fmt","regex::dfa","",13,{"inputs":[{"name":"cache"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",13,{"inputs":[{"name":"cache"}],"output":{"name":"cache"}}],[11,"fmt","","",14,{"inputs":[{"name":"cacheinner"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"cacheinner"}],"output":{"name":"cacheinner"}}],[11,"clone","","",15,{"inputs":[{"name":"transitions"}],"output":{"name":"transitions"}}],[11,"fmt","","",16,{"inputs":[{"name":"fsm"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",17,{"inputs":[{"name":"result"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",17,{"inputs":[{"name":"result"}],"output":{"name":"result"}}],[11,"is_match","","Returns true if this result corresponds to a match.",17,{"inputs":[{"name":"result"}],"output":{"name":"bool"}}],[11,"clone","","",18,{"inputs":[{"name":"state"}],"output":{"name":"state"}}],[11,"eq","","",19,{"inputs":[{"name":"statekey"},{"name":"statekey"}],"output":{"name":"bool"}}],[11,"ne","","",19,{"inputs":[{"name":"statekey"},{"name":"statekey"}],"output":{"name":"bool"}}],[11,"hash","","",19,null],[11,"fmt","","",19,{"inputs":[{"name":"statekey"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",19,{"inputs":[{"name":"statekey"}],"output":{"name":"statekey"}}],[11,"fmt","","",20,{"inputs":[{"name":"byte"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",20,{"inputs":[{"name":"byte"}],"output":{"name":"byte"}}],[11,"eq","","",21,{"inputs":[{"name":"emptyflags"},{"name":"emptyflags"}],"output":{"name":"bool"}}],[11,"ne","","",21,{"inputs":[{"name":"emptyflags"},{"name":"emptyflags"}],"output":{"name":"bool"}}],[11,"hash","","",21,null],[11,"default","","",21,{"inputs":[],"output":{"name":"emptyflags"}}],[11,"fmt","","",21,{"inputs":[{"name":"emptyflags"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",21,{"inputs":[{"name":"emptyflags"}],"output":{"name":"emptyflags"}}],[11,"eq","","",22,{"inputs":[{"name":"stateflags"},{"name":"stateflags"}],"output":{"name":"bool"}}],[11,"ne","","",22,{"inputs":[{"name":"stateflags"},{"name":"stateflags"}],"output":{"name":"bool"}}],[11,"hash","","",22,null],[11,"default","","",22,{"inputs":[],"output":{"name":"stateflags"}}],[11,"clone","","",22,{"inputs":[{"name":"stateflags"}],"output":{"name":"stateflags"}}],[11,"new","","Create new empty cache for the DFA engine.",13,{"inputs":[{"name":"program"}],"output":{"name":"cache"}}],[11,"forward","","",16,null],[11,"reverse","","",16,null],[11,"forward_many","","",16,null],[11,"fmt","","",18,{"inputs":[{"name":"state"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",15,{"inputs":[{"name":"transitions"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",23,{"inputs":[{"name":"transitionsrow"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",22,{"inputs":[{"name":"stateflags"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","regex::error","",24,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",24,{"inputs":[{"name":"error"}],"output":{"name":"str"}}],[11,"cause","","",24,{"inputs":[{"name":"error"}],"output":{"name":"option"}}],[11,"fmt","","",24,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",24,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"fmt","regex::exec","",25,{"inputs":[{"name":"execnosync"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",26,{"inputs":[{"name":"execreadonly"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a regex execution builder.",27,{"inputs":[{"name":"str"}],"output":{"name":"execbuilder"}}],[11,"new_many","","Like new, but compiles the union of the given regular expressions.",27,{"inputs":[{"name":"i"}],"output":{"name":"execbuilder"}}],[11,"new_options","","Create a regex execution builder.",27,{"inputs":[{"name":"regexoptions"}],"output":{"name":"execbuilder"}}],[11,"automatic","","Set the matching engine to be automatically determined.",27,{"inputs":[{"name":"execbuilder"}],"output":{"name":"execbuilder"}}],[11,"nfa","","Sets the matching engine to use the NFA algorithm no matter what\noptimizations are possible.",27,{"inputs":[{"name":"execbuilder"}],"output":{"name":"execbuilder"}}],[11,"bounded_backtracking","","Sets the matching engine to use a bounded backtracking engine no\nmatter what optimizations are possible.",27,{"inputs":[{"name":"execbuilder"}],"output":{"name":"execbuilder"}}],[11,"bytes","","Compiles byte based programs for use with the NFA matching engines.",27,{"inputs":[{"name":"execbuilder"},{"name":"bool"}],"output":{"name":"execbuilder"}}],[11,"only_utf8","","When disabled, the program compiled may match arbitrary bytes.",27,{"inputs":[{"name":"execbuilder"},{"name":"bool"}],"output":{"name":"execbuilder"}}],[11,"unicode","","Set the Unicode flag.",27,{"inputs":[{"name":"execbuilder"},{"name":"bool"}],"output":{"name":"execbuilder"}}],[11,"build","","Build an executor that can run a regular expression.",27,{"inputs":[{"name":"execbuilder"}],"output":{"name":"result"}}],[11,"slots_len","","",28,{"inputs":[{"name":"execnosyncstr"}],"output":{"name":"usize"}}],[11,"next_after_empty","","",28,{"inputs":[{"name":"execnosyncstr"},{"name":"str"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"shortest_match_at","","",28,{"inputs":[{"name":"execnosyncstr"},{"name":"str"},{"name":"usize"}],"output":{"name":"option"}}],[11,"is_match_at","","",28,{"inputs":[{"name":"execnosyncstr"},{"name":"str"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"find_at","","",28,{"inputs":[{"name":"execnosyncstr"},{"name":"str"},{"name":"usize"}],"output":{"name":"option"}}],[11,"read_captures_at","","",28,null],[11,"slots_len","","Returns the number of capture slots in the regular expression. (There\nare two slots for every capture group, corresponding to possibly empty\nstart and end locations of the capture.)",25,{"inputs":[{"name":"execnosync"}],"output":{"name":"usize"}}],[11,"next_after_empty","","",25,null],[11,"shortest_match_at","","Returns the end of a match location, possibly occurring before the\nend location of the correct leftmost-first match.",25,null],[11,"is_match_at","","Returns true if and only if the regex matches text.",25,null],[11,"find_at","","Finds the start and end location of the leftmost-first match, starting\nat the given location.",25,null],[11,"read_captures_at","","Finds the start and end location of the leftmost-first match and also\nfills in all matching capture groups.",25,null],[11,"many_matches_at","","Finds which regular expressions match the given text.",25,null],[11,"capture_name_idx","","",25,{"inputs":[{"name":"execnosync"}],"output":{"name":"arc"}}],[11,"capture_name_idx","","",28,{"inputs":[{"name":"execnosyncstr"}],"output":{"name":"arc"}}],[11,"searcher","","Get a searcher that isn&#39;t Sync.",29,{"inputs":[{"name":"exec"}],"output":{"name":"execnosync"}}],[11,"searcher_str","","Get a searcher that isn&#39;t Sync and can match on &amp;str.",29,{"inputs":[{"name":"exec"}],"output":{"name":"execnosyncstr"}}],[11,"into_regex","","Build a Regex from this executor.",29,{"inputs":[{"name":"exec"}],"output":{"name":"regex"}}],[11,"into_regex_set","","Build a RegexSet from this executor.",29,{"inputs":[{"name":"exec"}],"output":{"name":"regexset"}}],[11,"into_byte_regex","","Build a Regex from this executor that can match arbitrary bytes.",29,{"inputs":[{"name":"exec"}],"output":{"name":"regex"}}],[11,"into_byte_regex_set","","Build a RegexSet from this executor that can match arbitrary bytes.",29,{"inputs":[{"name":"exec"}],"output":{"name":"regexset"}}],[11,"regex_strings","","The original regular expressions given by the caller that were\ncompiled.",29,null],[11,"capture_names","","Return a slice of capture names.",29,null],[11,"capture_name_idx","","Return a reference to named groups mapping (from group name to\ngroup position).",29,{"inputs":[{"name":"exec"}],"output":{"name":"arc"}}],[11,"clone","","",29,{"inputs":[{"name":"exec"}],"output":{"name":"exec"}}],[11,"fmt","","",30,{"inputs":[{"name":"matchtype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",30,{"inputs":[{"name":"matchtype"}],"output":{"name":"matchtype"}}],[11,"fmt","","",31,{"inputs":[{"name":"matchliteraltype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",31,{"inputs":[{"name":"matchliteraltype"}],"output":{"name":"matchliteraltype"}}],[11,"fmt","","",32,{"inputs":[{"name":"matchnfatype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",32,{"inputs":[{"name":"matchnfatype"}],"output":{"name":"matchnfatype"}}],[11,"fmt","","",33,{"inputs":[{"name":"programcacheinner"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",33,{"inputs":[{"name":"programcacheinner"}],"output":{"name":"programcacheinner"}}],[11,"fmt","regex::input","",34,{"inputs":[{"name":"inputat"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",34,{"inputs":[{"name":"inputat"}],"output":{"name":"inputat"}}],[11,"is_start","","Returns true iff this position is at the beginning of the input.",34,{"inputs":[{"name":"inputat"}],"output":{"name":"bool"}}],[11,"is_end","","Returns true iff this position is past the end of the input.",34,{"inputs":[{"name":"inputat"}],"output":{"name":"bool"}}],[11,"char","","Returns the character at this position.",34,{"inputs":[{"name":"inputat"}],"output":{"name":"char"}}],[11,"byte","","Returns the byte at this position.",34,{"inputs":[{"name":"inputat"}],"output":{"name":"option"}}],[11,"len","","Returns the UTF-8 width of the character at this position.",34,{"inputs":[{"name":"inputat"}],"output":{"name":"usize"}}],[11,"pos","","Returns the byte offset of this position.",34,{"inputs":[{"name":"inputat"}],"output":{"name":"usize"}}],[11,"next_pos","","Returns the byte offset of the next position in the input.",34,{"inputs":[{"name":"inputat"}],"output":{"name":"usize"}}],[11,"fmt","","",35,{"inputs":[{"name":"charinput"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",35,{"inputs":[{"name":"charinput"}],"output":{"name":"charinput"}}],[11,"new","","Return a new character input reader for the given string.",35,null],[11,"deref","","",35,null],[11,"at","","",35,{"inputs":[{"name":"charinput"},{"name":"usize"}],"output":{"name":"inputat"}}],[11,"next_char","","",35,{"inputs":[{"name":"charinput"},{"name":"inputat"}],"output":{"name":"char"}}],[11,"previous_char","","",35,{"inputs":[{"name":"charinput"},{"name":"inputat"}],"output":{"name":"char"}}],[11,"prefix_at","","",35,{"inputs":[{"name":"charinput"},{"name":"literalsearcher"},{"name":"inputat"}],"output":{"name":"option"}}],[11,"len","","",35,{"inputs":[{"name":"charinput"}],"output":{"name":"usize"}}],[11,"as_bytes","","",35,null],[11,"fmt","","",36,{"inputs":[{"name":"byteinput"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",36,{"inputs":[{"name":"byteinput"}],"output":{"name":"byteinput"}}],[11,"new","","Return a new byte-based input reader for the given string.",36,null],[11,"deref","","",36,null],[11,"at","","",36,{"inputs":[{"name":"byteinput"},{"name":"usize"}],"output":{"name":"inputat"}}],[11,"next_char","","",36,{"inputs":[{"name":"byteinput"},{"name":"inputat"}],"output":{"name":"char"}}],[11,"previous_char","","",36,{"inputs":[{"name":"byteinput"},{"name":"inputat"}],"output":{"name":"char"}}],[11,"prefix_at","","",36,{"inputs":[{"name":"byteinput"},{"name":"literalsearcher"},{"name":"inputat"}],"output":{"name":"option"}}],[11,"len","","",36,{"inputs":[{"name":"byteinput"}],"output":{"name":"usize"}}],[11,"as_bytes","","",36,null],[11,"cmp","","",37,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",37,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"option"}}],[11,"lt","","",37,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"le","","",37,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"gt","","",37,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"ge","","",37,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"eq","","",37,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"ne","","",37,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"hash","","",37,null],[11,"clone","","",37,{"inputs":[{"name":"char"}],"output":{"name":"char"}}],[11,"fmt","","",37,{"inputs":[{"name":"char"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"is_none","","Returns true iff the character is absent.",37,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[11,"len_utf8","","Returns the length of the character&#39;s UTF-8 encoding.",37,{"inputs":[{"name":"char"}],"output":{"name":"usize"}}],[11,"is_word_char","","Returns true iff the character is a word character.",37,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[11,"is_word_byte","","Returns true iff the byte is a word byte.",37,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[11,"as_char","","Converts the character to a real primitive `char`.",37,{"inputs":[{"name":"char"}],"output":{"name":"option"}}],[11,"from","","",37,{"inputs":[{"name":"char"}],"output":{"name":"char"}}],[11,"from","","",37,{"inputs":[{"name":"option"}],"output":{"name":"char"}}],[11,"eq","","",37,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",37,{"inputs":[{"name":"char"},{"name":"char"}],"output":{"name":"option"}}],[11,"fmt","regex::literals","",38,{"inputs":[{"name":"literalsearcher"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",38,{"inputs":[{"name":"literalsearcher"}],"output":{"name":"literalsearcher"}}],[11,"fmt","","",39,{"inputs":[{"name":"matcher"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",39,{"inputs":[{"name":"matcher"}],"output":{"name":"matcher"}}],[11,"empty","","Returns a matcher that never matches and never advances the input.",38,{"inputs":[],"output":{"name":"literalsearcher"}}],[11,"prefixes","","Returns a matcher for literal prefixes from the given set.",38,{"inputs":[{"name":"literals"}],"output":{"name":"literalsearcher"}}],[11,"suffixes","","Returns a matcher for literal suffixes from the given set.",38,{"inputs":[{"name":"literals"}],"output":{"name":"literalsearcher"}}],[11,"complete","","Returns true if all matches comprise the entire regular expression.",38,{"inputs":[{"name":"literalsearcher"}],"output":{"name":"bool"}}],[11,"find","","Find the position of a literal in `haystack` if it exists.",38,null],[11,"find_start","","Like find, except matches must start at index `0`.",38,null],[11,"find_end","","Like find, except matches must end at index `haystack.len()`.",38,null],[11,"iter","","Returns an iterator over all literals to be matched.",38,{"inputs":[{"name":"literalsearcher"}],"output":{"name":"literaliter"}}],[11,"lcp","","Returns a matcher for the longest common prefix of this matcher.",38,{"inputs":[{"name":"literalsearcher"}],"output":{"name":"singlesearch"}}],[11,"lcs","","Returns a matcher for the longest common suffix of this matcher.",38,{"inputs":[{"name":"literalsearcher"}],"output":{"name":"singlesearch"}}],[11,"is_empty","","Returns true iff this prefix is empty.",38,{"inputs":[{"name":"literalsearcher"}],"output":{"name":"bool"}}],[11,"len","","Returns the number of prefixes in this machine.",38,{"inputs":[{"name":"literalsearcher"}],"output":{"name":"usize"}}],[11,"approximate_size","","Return the approximate heap usage of literals in bytes.",38,{"inputs":[{"name":"literalsearcher"}],"output":{"name":"usize"}}],[11,"next","","",40,{"inputs":[{"name":"literaliter"}],"output":{"name":"option"}}],[11,"fmt","","",41,{"inputs":[{"name":"singlebyteset"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",41,{"inputs":[{"name":"singlebyteset"}],"output":{"name":"singlebyteset"}}],[11,"fmt","","",42,{"inputs":[{"name":"singlesearch"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",42,{"inputs":[{"name":"singlesearch"}],"output":{"name":"singlesearch"}}],[11,"find","","",42,null],[11,"is_suffix","","",42,null],[11,"len","","",42,{"inputs":[{"name":"singlesearch"}],"output":{"name":"usize"}}],[11,"fmt","regex::pikevm","",43,{"inputs":[{"name":"fsm"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",44,{"inputs":[{"name":"cache"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",44,{"inputs":[{"name":"cache"}],"output":{"name":"cache"}}],[11,"fmt","","",45,{"inputs":[{"name":"threads"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",45,{"inputs":[{"name":"threads"}],"output":{"name":"threads"}}],[11,"fmt","","",46,{"inputs":[{"name":"followepsilon"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",46,{"inputs":[{"name":"followepsilon"}],"output":{"name":"followepsilon"}}],[11,"new","","Create a new allocation used by the NFA machine to record execution\nand captures.",44,{"inputs":[{"name":"program"}],"output":{"name":"cache"}}],[11,"exec","","Execute the NFA matching engine.",43,null],[11,"clone","regex::prog","",47,{"inputs":[{"name":"program"}],"output":{"name":"program"}}],[11,"new","","Creates an empty instruction sequence. Fields are given default\nvalues.",47,{"inputs":[],"output":{"name":"program"}}],[11,"skip","","If pc is an index to a no-op instruction (like Save), then return the\nnext pc that is not a no-op instruction.",47,{"inputs":[{"name":"program"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"leads_to_match","","Return true if and only if an execution engine at instruction `pc` will\nalways lead to a match.",47,{"inputs":[{"name":"program"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"needs_dotstar","","Returns true if the current configuration demands that an implicit\n`.*?` be prepended to the instruction sequence.",47,{"inputs":[{"name":"program"}],"output":{"name":"bool"}}],[11,"uses_bytes","","Returns true if this program uses Byte instructions instead of\nChar/Range instructions.",47,{"inputs":[{"name":"program"}],"output":{"name":"bool"}}],[11,"only_utf8","","Returns true if this program exclusively matches valid UTF-8 bytes.",47,{"inputs":[{"name":"program"}],"output":{"name":"bool"}}],[11,"approximate_size","","Return the approximate heap usage of this instruction sequence in\nbytes.",47,{"inputs":[{"name":"program"}],"output":{"name":"usize"}}],[11,"deref","","",47,null],[11,"fmt","","",47,{"inputs":[{"name":"program"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",48,{"inputs":[{"name":"inst"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",48,{"inputs":[{"name":"inst"}],"output":{"name":"inst"}}],[11,"fmt","","",49,{"inputs":[{"name":"instsave"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",49,{"inputs":[{"name":"instsave"}],"output":{"name":"instsave"}}],[11,"fmt","","",50,{"inputs":[{"name":"instsplit"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",50,{"inputs":[{"name":"instsplit"}],"output":{"name":"instsplit"}}],[11,"fmt","","",51,{"inputs":[{"name":"instemptylook"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",51,{"inputs":[{"name":"instemptylook"}],"output":{"name":"instemptylook"}}],[11,"eq","","",52,{"inputs":[{"name":"emptylook"},{"name":"emptylook"}],"output":{"name":"bool"}}],[11,"ne","","",52,{"inputs":[{"name":"emptylook"},{"name":"emptylook"}],"output":{"name":"bool"}}],[11,"fmt","","",52,{"inputs":[{"name":"emptylook"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",52,{"inputs":[{"name":"emptylook"}],"output":{"name":"emptylook"}}],[11,"matches","","Tests whether the pair of characters matches this zero-width\ninstruction.",51,{"inputs":[{"name":"instemptylook"},{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[11,"fmt","","",53,{"inputs":[{"name":"instchar"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",53,{"inputs":[{"name":"instchar"}],"output":{"name":"instchar"}}],[11,"fmt","","",54,{"inputs":[{"name":"instranges"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",54,{"inputs":[{"name":"instranges"}],"output":{"name":"instranges"}}],[11,"matches","","Tests whether the given input character matches this instruction.",54,{"inputs":[{"name":"instranges"},{"name":"char"}],"output":{"name":"bool"}}],[11,"num_chars","","Return the number of distinct characters represented by all of the\nranges.",54,{"inputs":[{"name":"instranges"}],"output":{"name":"usize"}}],[11,"fmt","","",55,{"inputs":[{"name":"instbytes"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",55,{"inputs":[{"name":"instbytes"}],"output":{"name":"instbytes"}}],[11,"matches","","Returns true if and only if the given byte is in this range.",55,{"inputs":[{"name":"instbytes"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"fmt","regex::re_builder","",56,{"inputs":[{"name":"regexoptions"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",56,{"inputs":[{"name":"regexoptions"}],"output":{"name":"regexoptions"}}],[11,"default","","",56,{"inputs":[],"output":{"name":"regexoptions"}}],[11,"new","regex::re_builder::bytes","Create a new regular expression builder with the given pattern.",57,{"inputs":[{"name":"str"}],"output":{"name":"regexbuilder"}}],[11,"compile","","Consume the builder and compile the regular expression.",57,{"inputs":[{"name":"regexbuilder"}],"output":{"name":"result"}}],[11,"case_insensitive","","Set the value for the case insensitive (`i`) flag.",57,{"inputs":[{"name":"regexbuilder"},{"name":"bool"}],"output":{"name":"regexbuilder"}}],[11,"multi_line","","Set the value for the multi-line matching (`m`) flag.",57,{"inputs":[{"name":"regexbuilder"},{"name":"bool"}],"output":{"name":"regexbuilder"}}],[11,"dot_matches_new_line","","Set the value for the any character (`s`) flag, where in `.` matches\nanything when `s` is set and matches anything except for new line when\nit is not set (the default).",57,{"inputs":[{"name":"regexbuilder"},{"name":"bool"}],"output":{"name":"regexbuilder"}}],[11,"swap_greed","","Set the value for the greedy swap (`U`) flag.",57,{"inputs":[{"name":"regexbuilder"},{"name":"bool"}],"output":{"name":"regexbuilder"}}],[11,"ignore_whitespace","","Set the value for the ignore whitespace (`x`) flag.",57,{"inputs":[{"name":"regexbuilder"},{"name":"bool"}],"output":{"name":"regexbuilder"}}],[11,"unicode","","Set the value for the Unicode (`u`) flag.",57,{"inputs":[{"name":"regexbuilder"},{"name":"bool"}],"output":{"name":"regexbuilder"}}],[11,"size_limit","","Set the approximate size limit of the compiled regular expression.",57,{"inputs":[{"name":"regexbuilder"},{"name":"usize"}],"output":{"name":"regexbuilder"}}],[11,"dfa_size_limit","","Set the approximate size of the cache used by the DFA.",57,{"inputs":[{"name":"regexbuilder"},{"name":"usize"}],"output":{"name":"regexbuilder"}}],[11,"new","regex::re_builder::unicode","Create a new regular expression builder with the given pattern.",58,{"inputs":[{"name":"str"}],"output":{"name":"regexbuilder"}}],[11,"compile","","Consume the builder and compile the regular expression.",58,{"inputs":[{"name":"regexbuilder"}],"output":{"name":"result"}}],[11,"case_insensitive","","Set the value for the case insensitive (`i`) flag.",58,{"inputs":[{"name":"regexbuilder"},{"name":"bool"}],"output":{"name":"regexbuilder"}}],[11,"multi_line","","Set the value for the multi-line matching (`m`) flag.",58,{"inputs":[{"name":"regexbuilder"},{"name":"bool"}],"output":{"name":"regexbuilder"}}],[11,"dot_matches_new_line","","Set the value for the any character (`s`) flag, where in `.` matches\nanything when `s` is set and matches anything except for new line when\nit is not set (the default).",58,{"inputs":[{"name":"regexbuilder"},{"name":"bool"}],"output":{"name":"regexbuilder"}}],[11,"swap_greed","","Set the value for the greedy swap (`U`) flag.",58,{"inputs":[{"name":"regexbuilder"},{"name":"bool"}],"output":{"name":"regexbuilder"}}],[11,"ignore_whitespace","","Set the value for the ignore whitespace (`x`) flag.",58,{"inputs":[{"name":"regexbuilder"},{"name":"bool"}],"output":{"name":"regexbuilder"}}],[11,"unicode","","Set the value for the Unicode (`u`) flag.",58,{"inputs":[{"name":"regexbuilder"},{"name":"bool"}],"output":{"name":"regexbuilder"}}],[11,"size_limit","","Set the approximate size limit of the compiled regular expression.",58,{"inputs":[{"name":"regexbuilder"},{"name":"usize"}],"output":{"name":"regexbuilder"}}],[11,"dfa_size_limit","","Set the approximate size of the cache used by the DFA.",58,{"inputs":[{"name":"regexbuilder"},{"name":"usize"}],"output":{"name":"regexbuilder"}}],[11,"clone","regex::re_bytes","",59,{"inputs":[{"name":"regex"}],"output":{"name":"regex"}}],[11,"fmt","","Shows the original regular expression.",59,{"inputs":[{"name":"regex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","Shows the original regular expression.",59,{"inputs":[{"name":"regex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_str","","Attempts to parse a string into a regular expression",59,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"new","","Compiles a regular expression. Once compiled, it can be used repeatedly\nto search, split or replace text in a string.",59,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"with_size_limit","","Compiles a regular expression with the given size limit.",59,{"inputs":[{"name":"usize"},{"name":"str"}],"output":{"name":"result"}}],[11,"is_match","","Returns true if and only if the regex matches the string given.",59,null],[11,"find","","Returns the start and end byte range of the leftmost-first match in\n`text`. If no match exists, then `None` is returned.",59,null],[11,"find_iter","","Returns an iterator for each successive non-overlapping match in\n`text`, returning the start and end byte indices with respect to\n`text`.",59,null],[11,"captures","","Returns the capture groups corresponding to the leftmost-first\nmatch in `text`. Capture group `0` always corresponds to the entire\nmatch. If no match is found, then `None` is returned.",59,null],[11,"captures_iter","","Returns an iterator over all the non-overlapping capture groups matched\nin `text`. This is operationally the same as `find_iter`, except it\nyields information about submatches.",59,null],[11,"split","","Returns an iterator of substrings of `text` delimited by a match of the\nregular expression. Namely, each element of the iterator corresponds to\ntext that *isn&#39;t* matched by the regular expression.",59,null],[11,"splitn","","Returns an iterator of at most `limit` substrings of `text` delimited\nby a match of the regular expression. (A `limit` of `0` will return no\nsubstrings.) Namely, each element of the iterator corresponds to text\nthat *isn&#39;t* matched by the regular expression. The remainder of the\nstring that is not split will be the last element in the iterator.",59,null],[11,"replace","","Replaces the leftmost-first match with the replacement provided. The\nreplacement can be a regular byte string (where `$N` and `$name` are\nexpanded to match capture groups) or a function that takes the matches&#39;\n`Captures` and returns the replaced byte string.",59,null],[11,"replace_all","","Replaces all non-overlapping matches in `text` with the replacement\nprovided. This is the same as calling `replacen` with `limit` set to\n`0`.",59,null],[11,"replacen","","Replaces at most `limit` non-overlapping matches in `text` with the\nreplacement provided. If `limit` is 0, then all non-overlapping matches\nare replaced.",59,null],[11,"shortest_match","","Returns the end location of a match in the text given.",59,null],[11,"as_str","","Returns the original string of this regex.",59,{"inputs":[{"name":"regex"}],"output":{"name":"str"}}],[11,"capture_names","","Returns an iterator over the capture names.",59,{"inputs":[{"name":"regex"}],"output":{"name":"capturenames"}}],[11,"captures_len","","Returns the number of captures.",59,{"inputs":[{"name":"regex"}],"output":{"name":"usize"}}],[11,"next","","",60,{"inputs":[{"name":"findmatches"}],"output":{"name":"option"}}],[11,"next","","",61,{"inputs":[{"name":"findcaptures"}],"output":{"name":"option"}}],[11,"next","","",62,{"inputs":[{"name":"splits"}],"output":{"name":"option"}}],[11,"next","","",63,{"inputs":[{"name":"splitsn"}],"output":{"name":"option"}}],[11,"next","","",64,{"inputs":[{"name":"capturenames"}],"output":{"name":"option"}}],[11,"size_hint","","",64,null],[11,"pos","","Returns the start and end positions of the Nth capture group. Returns\n`None` if `i` is not a valid capture group or if the capture group did\nnot match anything. The positions returned are *always* byte indices\nwith respect to the original byte string matched.",65,{"inputs":[{"name":"captures"},{"name":"usize"}],"output":{"name":"option"}}],[11,"at","","Returns the matched string for the capture group `i`.  If `i` isn&#39;t\na valid capture group or didn&#39;t match anything, then `None` is\nreturned.",65,{"inputs":[{"name":"captures"},{"name":"usize"}],"output":{"name":"option"}}],[11,"name","","Returns the matched string for the capture group named `name`.  If\n`name` isn&#39;t a valid capture group or didn&#39;t match anything, then\n`None` is returned.",65,{"inputs":[{"name":"captures"},{"name":"str"}],"output":{"name":"option"}}],[11,"iter","","Creates an iterator of all the capture groups in order of appearance\nin the regular expression.",65,{"inputs":[{"name":"captures"}],"output":{"name":"subcaptures"}}],[11,"iter_pos","","Creates an iterator of all the capture group positions in order of\nappearance in the regular expression. Positions are byte indices\nin terms of the original string matched.",65,{"inputs":[{"name":"captures"}],"output":{"name":"subcapturespos"}}],[11,"iter_named","","Creates an iterator of all named groups as an tuple with the group\nname and the value. The iterator returns these values in arbitrary\norder.",65,{"inputs":[{"name":"captures"}],"output":{"name":"subcapturesnamed"}}],[11,"expand","","Expands all instances of `$name` in `text` to the corresponding capture\ngroup `name`, and writes them to the `dst` buffer given.",65,null],[11,"len","","Returns the number of captured groups.",65,{"inputs":[{"name":"captures"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns true if and only if there are no captured groups.",65,{"inputs":[{"name":"captures"}],"output":{"name":"bool"}}],[11,"fmt","","",65,{"inputs":[{"name":"captures"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",66,{"inputs":[{"name":"capturesdebug"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"index","","",65,null],[11,"index","","",65,null],[11,"next","","",67,{"inputs":[{"name":"subcaptures"}],"output":{"name":"option"}}],[11,"next","","",68,{"inputs":[{"name":"subcapturespos"}],"output":{"name":"option"}}],[11,"next","","",69,{"inputs":[{"name":"subcapturesnamed"}],"output":{"name":"option"}}],[11,"replace_append","","",70,null],[11,"no_expansion","","",70,{"inputs":[{"name":"noexpand"}],"output":{"name":"option"}}],[11,"clone","regex::re_plugin","",71,{"inputs":[{"name":"plugin"}],"output":{"name":"plugin"}}],[11,"slots_len","","",71,{"inputs":[{"name":"plugin"}],"output":{"name":"usize"}}],[11,"next_after_empty","","",71,{"inputs":[{"name":"plugin"},{"name":"str"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"shortest_match_at","","",71,{"inputs":[{"name":"plugin"},{"name":"str"},{"name":"usize"}],"output":{"name":"option"}}],[11,"is_match_at","","",71,{"inputs":[{"name":"plugin"},{"name":"str"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"find_at","","",71,{"inputs":[{"name":"plugin"},{"name":"str"},{"name":"usize"}],"output":{"name":"option"}}],[11,"read_captures_at","","",71,null],[11,"clone","regex::re_set::unicode","",72,{"inputs":[{"name":"regexset"}],"output":{"name":"regexset"}}],[11,"new","","Create a new regex set with the given regular expressions.",72,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"is_match","","Returns true if and only if one of the regexes in this set matches\nthe text given.",72,{"inputs":[{"name":"regexset"},{"name":"str"}],"output":{"name":"bool"}}],[11,"matches","","Returns the set of regular expressions that match in the given text.",72,{"inputs":[{"name":"regexset"},{"name":"str"}],"output":{"name":"setmatches"}}],[11,"len","","Returns the total number of regular expressions in this set.",72,{"inputs":[{"name":"regexset"}],"output":{"name":"usize"}}],[11,"fmt","","",73,{"inputs":[{"name":"setmatches"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",73,{"inputs":[{"name":"setmatches"}],"output":{"name":"setmatches"}}],[11,"matched_any","","Whether this set contains any matches.",73,{"inputs":[{"name":"setmatches"}],"output":{"name":"bool"}}],[11,"matched","","Whether the regex at the given index matched.",73,{"inputs":[{"name":"setmatches"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"len","","The total number of regexes in the set that created these matches.",73,{"inputs":[{"name":"setmatches"}],"output":{"name":"usize"}}],[11,"iter","","Returns an iterator over indexes in the regex that matched.",73,{"inputs":[{"name":"setmatches"}],"output":{"name":"setmatchesiter"}}],[11,"into_iter","","",73,null],[11,"next","","",74,{"inputs":[{"name":"setmatchesintoiter"}],"output":{"name":"option"}}],[11,"clone","","",75,{"inputs":[{"name":"setmatchesiter"}],"output":{"name":"setmatchesiter"}}],[11,"next","","",75,{"inputs":[{"name":"setmatchesiter"}],"output":{"name":"option"}}],[11,"fmt","","",72,{"inputs":[{"name":"regexset"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","regex::re_set::bytes","",76,{"inputs":[{"name":"regexset"}],"output":{"name":"regexset"}}],[11,"new","","Create a new regex set with the given regular expressions.",76,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"is_match","","Returns true if and only if one of the regexes in this set matches\nthe text given.",76,null],[11,"matches","","Returns the set of regular expressions that match in the given text.",76,null],[11,"len","","Returns the total number of regular expressions in this set.",76,{"inputs":[{"name":"regexset"}],"output":{"name":"usize"}}],[11,"fmt","","",77,{"inputs":[{"name":"setmatches"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",77,{"inputs":[{"name":"setmatches"}],"output":{"name":"setmatches"}}],[11,"matched_any","","Whether this set contains any matches.",77,{"inputs":[{"name":"setmatches"}],"output":{"name":"bool"}}],[11,"matched","","Whether the regex at the given index matched.",77,{"inputs":[{"name":"setmatches"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"len","","The total number of regexes in the set that created these matches.",77,{"inputs":[{"name":"setmatches"}],"output":{"name":"usize"}}],[11,"iter","","Returns an iterator over indexes in the regex that matched.",77,{"inputs":[{"name":"setmatches"}],"output":{"name":"setmatchesiter"}}],[11,"into_iter","","",77,null],[11,"next","","",78,{"inputs":[{"name":"setmatchesintoiter"}],"output":{"name":"option"}}],[11,"clone","","",79,{"inputs":[{"name":"setmatchesiter"}],"output":{"name":"setmatchesiter"}}],[11,"next","","",79,{"inputs":[{"name":"setmatchesiter"}],"output":{"name":"option"}}],[11,"fmt","","",76,{"inputs":[{"name":"regexset"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"text","regex::re_trait","Return the text being searched.",80,null],[11,"regex","","Return the underlying regex.",80,{"inputs":[{"name":"findmatches"}],"output":{"name":"r"}}],[11,"next","","",80,{"inputs":[{"name":"findmatches"}],"output":{"name":"option"}}],[11,"text","","Return the text being searched.",81,null],[11,"regex","","Return the underlying regex.",81,{"inputs":[{"name":"findcaptures"}],"output":{"name":"r"}}],[11,"next","","",81,{"inputs":[{"name":"findcaptures"}],"output":{"name":"option"}}],[11,"clone","regex::re_unicode","",2,{"inputs":[{"name":"regex"}],"output":{"name":"regex"}}],[11,"clone","","",82,{"inputs":[{"name":"_regex"}],"output":{"name":"_regex"}}],[11,"fmt","","Shows the original regular expression.",2,{"inputs":[{"name":"regex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","Shows the original regular expression.",2,{"inputs":[{"name":"regex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"regex"},{"name":"regex"}],"output":{"name":"bool"}}],[11,"from_str","","Attempts to parse a string into a regular expression",2,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"next","","",83,{"inputs":[{"name":"capturenames"}],"output":{"name":"option"}}],[11,"size_hint","","",83,null],[11,"reg_replace","","",84,{"inputs":[{"name":"noexpand"},{"name":"captures"}],"output":{"name":"cow"}}],[11,"no_expand","","",84,{"inputs":[{"name":"noexpand"}],"output":{"name":"option"}}],[11,"next","","",85,{"inputs":[{"name":"regexsplits"}],"output":{"name":"option"}}],[11,"next","","",86,{"inputs":[{"name":"regexsplitsn"}],"output":{"name":"option"}}],[11,"next","","",87,{"inputs":[{"name":"namedgroupsiter"}],"output":{"name":"option"}}],[11,"pos","","Returns the start and end positions of the Nth capture group. Returns\n`None` if `i` is not a valid capture group or if the capture group did\nnot match anything. The positions returned are *always* byte indices\nwith respect to the original string matched.",88,{"inputs":[{"name":"captures"},{"name":"usize"}],"output":{"name":"option"}}],[11,"at","","Returns the matched string for the capture group `i`.  If `i` isn&#39;t\na valid capture group or didn&#39;t match anything, then `None` is\nreturned.",88,{"inputs":[{"name":"captures"},{"name":"usize"}],"output":{"name":"option"}}],[11,"name","","Returns the matched string for the capture group named `name`.  If\n`name` isn&#39;t a valid capture group or didn&#39;t match anything, then\n`None` is returned.",88,{"inputs":[{"name":"captures"},{"name":"str"}],"output":{"name":"option"}}],[11,"iter","","Creates an iterator of all the capture groups in order of appearance\nin the regular expression.",88,{"inputs":[{"name":"captures"}],"output":{"name":"subcaptures"}}],[11,"iter_pos","","Creates an iterator of all the capture group positions in order of\nappearance in the regular expression. Positions are byte indices\nin terms of the original string matched.",88,{"inputs":[{"name":"captures"}],"output":{"name":"subcapturespos"}}],[11,"iter_named","","Creates an iterator of all named groups as an tuple with the group\nname and the value. The iterator returns these values in arbitrary\norder.",88,{"inputs":[{"name":"captures"}],"output":{"name":"subcapturesnamed"}}],[11,"expand","","Expands all instances of `$name` in `text` to the corresponding capture\ngroup `name`.",88,{"inputs":[{"name":"captures"},{"name":"str"}],"output":{"name":"string"}}],[11,"len","","Returns the number of captured groups.",88,{"inputs":[{"name":"captures"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns true if and only if there are no captured groups.",88,{"inputs":[{"name":"captures"}],"output":{"name":"bool"}}],[11,"fmt","","",88,{"inputs":[{"name":"captures"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",89,{"inputs":[{"name":"capturesdebug"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"index","","",88,{"inputs":[{"name":"captures"},{"name":"usize"}],"output":{"name":"str"}}],[11,"index","","",88,{"inputs":[{"name":"captures"},{"name":"str"}],"output":{"name":"str"}}],[11,"next","","",90,{"inputs":[{"name":"subcaptures"}],"output":{"name":"option"}}],[11,"next","","",91,{"inputs":[{"name":"subcapturespos"}],"output":{"name":"option"}}],[11,"next","","",92,{"inputs":[{"name":"subcapturesnamed"}],"output":{"name":"option"}}],[11,"next","","",93,{"inputs":[{"name":"findcaptures"}],"output":{"name":"option"}}],[11,"next","","",94,{"inputs":[{"name":"findmatches"}],"output":{"name":"option"}}],[11,"fmt","regex::sparse","",95,{"inputs":[{"name":"sparseset"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",95,{"inputs":[{"name":"sparseset"}],"output":{"name":"sparseset"}}],[11,"new","","",95,{"inputs":[{"name":"usize"}],"output":{"name":"sparseset"}}],[11,"len","","",95,{"inputs":[{"name":"sparseset"}],"output":{"name":"usize"}}],[11,"is_empty","","",95,{"inputs":[{"name":"sparseset"}],"output":{"name":"bool"}}],[11,"capacity","","",95,{"inputs":[{"name":"sparseset"}],"output":{"name":"usize"}}],[11,"add","","",95,null],[11,"contains_ip","","",95,{"inputs":[{"name":"sparseset"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"clear","","",95,null],[11,"deref","","",95,null],[11,"prn","nmea","",96,{"inputs":[{"name":"satellite"}],"output":{"name":"u32"}}],[11,"elevation","","",96,{"inputs":[{"name":"satellite"}],"output":{"name":"f32"}}],[11,"azimuth","","",96,{"inputs":[{"name":"satellite"}],"output":{"name":"f32"}}],[11,"snr","","",96,{"inputs":[{"name":"satellite"}],"output":{"name":"u32"}}],[11,"new","","Constructs a new `Nmea`.\nThis struct parses NMEA sentences, including checksum checks and sentence\nvalidation.",97,{"inputs":[],"output":{"name":"nmea"}}],[11,"fix_timestamp","","Returns fix type",97,{"inputs":[{"name":"nmea"}],"output":{"name":"option"}}],[11,"fix_type","","Returns fix type",97,{"inputs":[{"name":"nmea"}],"output":{"name":"fixtype"}}],[11,"latitude","","Returns last fixed latitude in degress. None if not fixed.",97,{"inputs":[{"name":"nmea"}],"output":{"name":"option"}}],[11,"longitude","","Returns last fixed longitude in degress. None if not fixed.",97,{"inputs":[{"name":"nmea"}],"output":{"name":"option"}}],[11,"altitude","","Returns latitude from last fix. None if not available.",97,{"inputs":[{"name":"nmea"}],"output":{"name":"option"}}],[11,"fix_satellites","","Returns the number of satellites use for fix.",97,{"inputs":[{"name":"nmea"}],"output":{"name":"option"}}],[11,"hdop","","Returns the number fix HDOP",97,{"inputs":[{"name":"nmea"}],"output":{"name":"option"}}],[11,"geoid_height","","Returns the height of geoid above WGS84",97,{"inputs":[{"name":"nmea"}],"output":{"name":"option"}}],[11,"satellites_in_view","","Returns the height of geoid above WGS84",97,{"inputs":[{"name":"nmea"}],"output":{"name":"vec"}}],[11,"sentence_type","","Returns the NMEA sentence type.",97,{"inputs":[{"name":"nmea"},{"name":"str"}],"output":{"name":"result"}}],[11,"parse","","Parse any NMEA sentence and stores the result. The type of sentence\nis returnd if implemented and valid.",97,{"inputs":[{"name":"nmea"},{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",97,{"inputs":[{"name":"nmea"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",97,{"inputs":[{"name":"nmea"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"sentencetype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"sentencetype"},{"name":"sentencetype"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"sentencetype"},{"name":"sentencetype"}],"output":{"name":"bool"}}],[11,"from","","",0,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"fmt","","",1,{"inputs":[{"name":"fixtype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"fixtype"},{"name":"fixtype"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"fixtype"},{"name":"fixtype"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"fixtype"}],"output":{"name":"fixtype"}}],[11,"from","","",1,{"inputs":[{"name":"str"}],"output":{"name":"self"}}]],"paths":[[4,"SentenceType"],[4,"FixType"],[3,"Regex"],[3,"Bounded"],[3,"Cache"],[4,"Job"],[3,"Patch"],[3,"Compiler"],[4,"Hole"],[4,"MaybeInst"],[4,"InstHole"],[3,"SuffixCacheEntry"],[3,"SuffixCacheKey"],[3,"Cache"],[3,"CacheInner"],[3,"Transitions"],[3,"Fsm"],[4,"Result"],[3,"State"],[3,"StateKey"],[3,"Byte"],[3,"EmptyFlags"],[3,"StateFlags"],[3,"TransitionsRow"],[4,"Error"],[3,"ExecNoSync"],[3,"ExecReadOnly"],[3,"ExecBuilder"],[3,"ExecNoSyncStr"],[3,"Exec"],[4,"MatchType"],[4,"MatchLiteralType"],[4,"MatchNfaType"],[3,"ProgramCacheInner"],[3,"InputAt"],[3,"CharInput"],[3,"ByteInput"],[3,"Char"],[3,"LiteralSearcher"],[4,"Matcher"],[4,"LiteralIter"],[3,"SingleByteSet"],[3,"SingleSearch"],[3,"Fsm"],[3,"Cache"],[3,"Threads"],[4,"FollowEpsilon"],[3,"Program"],[4,"Inst"],[3,"InstSave"],[3,"InstSplit"],[3,"InstEmptyLook"],[4,"EmptyLook"],[3,"InstChar"],[3,"InstRanges"],[3,"InstBytes"],[3,"RegexOptions"],[3,"RegexBuilder"],[3,"RegexBuilder"],[3,"Regex"],[3,"FindMatches"],[3,"FindCaptures"],[3,"Splits"],[3,"SplitsN"],[3,"CaptureNames"],[3,"Captures"],[3,"CapturesDebug"],[3,"SubCaptures"],[3,"SubCapturesPos"],[3,"SubCapturesNamed"],[3,"NoExpand"],[3,"Plugin"],[3,"RegexSet"],[3,"SetMatches"],[3,"SetMatchesIntoIter"],[3,"SetMatchesIter"],[3,"RegexSet"],[3,"SetMatches"],[3,"SetMatchesIntoIter"],[3,"SetMatchesIter"],[3,"FindMatches"],[3,"FindCaptures"],[4,"_Regex"],[3,"CaptureNames"],[3,"NoExpand"],[3,"RegexSplits"],[3,"RegexSplitsN"],[4,"NamedGroupsIter"],[3,"Captures"],[3,"CapturesDebug"],[3,"SubCaptures"],[3,"SubCapturesPos"],[3,"SubCapturesNamed"],[3,"FindCaptures"],[3,"FindMatches"],[3,"SparseSet"],[3,"Satellite"],[3,"Nmea"]]};
initSearch(searchIndex);
